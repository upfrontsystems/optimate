"""Models file contains resources used in the project
"""

import os
import hashlib
from zope.sqlalchemy import ZopeTransactionExtension
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.ext.hybrid import hybrid_property
from decimal import *
import sqlalchemy.types as types

from sqlalchemy import (
    Table,
    Column,
    Index,
    Integer,
    Float,
    Text,
    Unicode,
    DateTime,
    ForeignKey,
    ForeignKeyConstraint,
)

from sqlalchemy.orm import (
    scoped_session,
    sessionmaker,
    relationship,
    backref,
)

# Build the session and base used for the project
DBSession = scoped_session(
    sessionmaker(extension=ZopeTransactionExtension('changed')))
Base = declarative_base()

class SqliteNumeric(types.TypeDecorator):
    impl = types.String
    def load_dialect_impl(self, dialect):
        return dialect.type_descriptor(types.VARCHAR(100))
    def process_bind_param(self, value, dialect):
        return str(value)
    def process_result_value(self, value, dialect):
        if value != "None":
            return Decimal(value)
        else:
            return None

Numeric = SqliteNumeric

class Node(Base):

    """ The Node class is an extrapolation of the objects used in the hierarchy
        It has ID and ParentID attributes, the ParentID refers back to the ID
        of it's parent node.
        The ID of the node is generated by default using UUID.
        It also has a Children-Parent relationship attribute.
    """

    __tablename__ = 'Node'
    ID = Column(Integer, primary_key=True)
    ParentID = Column(
                    Integer,
                    ForeignKey('Node.ID', ondelete='CASCADE'),
                    index=True)
    OrderCost = Column(Numeric(12, 2), default=Decimal(0.00))
    ClaimedCost = Column(Numeric(12, 2), default=Decimal(0.00))
    RunningCost=Column(Numeric(12, 2), default=Decimal(0.00))
    IncomeRecieved=Column(Numeric(12, 2), default=Decimal(0.00))
    ClientCost=Column(Numeric(12, 2), default=Decimal(0.00))
    ProjectedProfit=Column(Numeric(12, 2), default=Decimal(0.00))
    ActualProfit=Column(Numeric(12, 2), default=Decimal(0.00))
    type = Column(Text(50))

    Children = relationship('Node',
                            cascade='all',
                            backref=backref('Parent', remote_side='Node.ID'),
                            )

    __mapper_args__ = {
        'polymorphic_identity': 'Node',
        'polymorphic_on': type
    }

    def getProjectID(self):
        """ Recursively calls the parent of this node until it finds the project
            whose parent is the root
        """
        parent = self.Parent
        if parent.ID == 0:
            return self.ID
        else:
            return parent.getProjectID()

        def __repr__(self):
            return '<Node(ID="%s", ParentID="%s")>' % (self.ID, self.ParentID)


class Project(Node):
    """ A table representing a Project in Optimate, it has an ID, Name,
        Description and ParentID that is the ID of its parent.
        It inherits from Node, and it's ID is linked to Node.ID
        It has copy and paste functions.
        It's total, ordered, and claimed attributes have properties that fire
        events
    """
    __tablename__ = 'Project'
    ID = Column(Integer,
                ForeignKey('Node.ID', ondelete='CASCADE'),
                primary_key=True)
    Name = Column(Text(50))
    Description = Column(Text(100))
    ClientID = Column(Integer, ForeignKey('Client.ID'))
    CityID = Column(Integer, ForeignKey('City.ID'))
    SiteAddress = Column(Text(50))
    FileNumber = Column(Text(50))
    _Total = Column('Total', Numeric)

    Clients = relationship('Client',
                            foreign_keys='Project.ClientID',
                            backref='Project')

    OverheadList = relationship('Overhead',
                                backref='Project')

    __mapper_args__ = {
        'polymorphic_identity': 'Project',
        'inherit_condition': (ID == Node.ID),
    }

    def recalculateTotal(self):
        """recursively recalculate the total of all the node in the hierarchy
        """
        total = Decimal(0.00)
        for child in self.Children:
            total += child.recalculateTotal()
        self._Total = total.quantize(Decimal('.01'))
        return self._Total

    def resetTotal(self):
        """return the sum of the totals of this node's children
        """
        total = Decimal(0.00)
        for child in self.Children:
            total += child.Total
        self.Total = total

    @hybrid_property
    def Total(self):
        """Get property total. If the Total has not been set yet, it is set to
           zero and recalculated
        """
        if self._Total == None:
            self.resetTotal()
        return self._Total.quantize(Decimal('.01'))

    @Total.setter
    def Total(self, total):
        """ Set total property.
        """
        self._Total = Decimal(total).quantize(Decimal('.01'))

    def copy(self, parentid):
        """copy returns an exact duplicate of this object,
        but with the ParentID specified.
        """
        copied = Project(Name=self.Name,
                         Description=self.Description,
                         ParentID=parentid,
                         ClientID=self.ClientID,
                         CityID=self.CityID,
                         SiteAddress=self.SiteAddress,
                         FileNumber=self.FileNumber,
                         _Total = self.Total,
                         OrderCost=self.OrderCost,
                         ClaimedCost=self.ClaimedCost,
                         RunningCost=self.RunningCost,
                         IncomeRecieved=self.IncomeRecieved,
                         ClientCost=self.ClientCost,
                         ProjectedProfit=self.ProjectedProfit,
                         ActualProfit=self.ActualProfit)

        return copied

    def paste(self, source, sourcechildren):
        """paste appends a source object to the children of this node,
           and then recursively does the same
           with each child of the source object.
        """
        self.Children.append(source)
        for child in sourcechildren:
            # The resource category is not pasted
            if child.type != 'ResourceCategory':
                source.paste(child.copy(source.ID), child.Children)

    def getComponents(self):
        """ Returns a list of all the Resources that are used by the children of
            the project. The resources are retrieved from its children and any
            children that are components return their resource
        """
        componentslist = []
        for child in self.Children:
            if child.type != 'ResourceCategory':
                componentslist += child.getComponents()
        return componentslist

    def toDict(self):
        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'Subitem': [{'Name': '...'}],
                'Client' : self.ClientID,
                'City' : self.CityID,
                'SiteAddress' : self.SiteAddress,
                'FileNumber' : self.FileNumber,
                'budg_cost': str(self.Total),
                'order_cost': str(self.OrderCost),
                'run_cost': str(self.RunningCost),
                'claim_cost': str(self.ClaimedCost),
                'income_rec': str(self.IncomeRecieved),
                'client_cost': str(self.ClientCost),
                'proj_profit': str(self.ProjectedProfit),
                'act_profit': str(self.ActualProfit),
                'NodeType': self.type,
                'NodeTypeAbbr' : 'P'}

    def toChildDict(self):
        """ Returns a dictionary of this node used in the childview
        """
        subitem = []
        if len(self.Children) > 0:
            subitem = [{'Name': '...', 'NodeType': 'Default'}]

        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'Subitem': subitem,
                'NodeType': self.type,
                'NodeTypeAbbr' : 'P'}

    def getGridData(self):
        return {'name': self.Name,
            'id': self.ID,
            'node_type': self.type,
            'budg_cost': str(self.Total),
            'order_cost': str(self.OrderCost.quantize(Decimal('.01'))),
            'run_cost': str(self.RunningCost.quantize(Decimal('.01'))),
            'claim_cost': str(self.ClaimedCost.quantize(Decimal('.01'))),
            'income_rec': str(self.IncomeRecieved.quantize(Decimal('.01'))),
            'client_cost': str(self.ClientCost.quantize(Decimal('.01'))),
            'proj_profit': str(self.ProjectedProfit.quantize(Decimal('.01'))),
            'act_profit': str(self.ActualProfit.quantize(Decimal('.01')))}

    def __repr__(self):
        """ Return a representation of this project
        """
        return '<Project(Name="%s", ID="%s", ParentID="%s")>' % (
            self.Name, self.ID, self.ParentID)


class City(Base):
    """ City defines a city used by a Project
    """
    __tablename__ = 'City'
    ID = Column(Integer, primary_key=True)
    Name = Column(Text(50))

    Projects = relationship('Project',
                         backref=backref('City'))
    Clients = relationship('Client',
                         backref=backref('City'))
    Suppliers = relationship('Supplier',
                         backref=backref('City'))

    def __repr__(self):
        return '<City(Name="%s", ID="%d")>' % (
            self.Name, self.ID)


class BudgetGroup(Node):
    """ A table representing a BudgetGroup in Optimate, it has an ID, Name,
        Description and ParentID that is the ID of its parent.
        It inherits from Node, and it's ID is linked to Node.ID
        It has copy and paste functions.
    """
    __tablename__ = 'BudgetGroup'
    ID = Column(Integer,
                ForeignKey('Node.ID', ondelete='CASCADE'), primary_key=True)
    Name = Column(Text(50))
    Description = Column(Text(100))
    _Total = Column('Total', Numeric)

    __mapper_args__ = {
        'polymorphic_identity': 'BudgetGroup',
        'inherit_condition': (ID == Node.ID),
    }

    def recalculateTotal(self):
        """recursively recalculate the total of all the node in the hierarchy
        """
        total = Decimal(0.00)
        for child in self.Children:
            total += child.recalculateTotal()
        self._Total = total
        return self._Total

    def resetTotal(self):
        """return the sum of the totals of this node's children
        """
        total = Decimal(0.00)
        for child in self.Children:
            total += child.Total
        self.Total = total

    @hybrid_property
    def Total(self):
        """Get the total property, reset the Total if it is None
        """
        if self._Total == None:
            self.resetTotal()
        return self._Total.quantize(Decimal('.01'))

    @Total.setter
    def Total(self, total):
        """ When the total is changed the parent's total is updated.
            If the total is none it is completely recalculated.
        """
        if self._Total == None:
            self.recalculateTotal()
        oldtotal = self.Total
        self._Total = Decimal(total).quantize(Decimal('.01'))
        difference = self._Total - oldtotal
        # update the parent with the new total
        parent = self.Parent
        if parent._Total == None:
            parent.resetTotal()
        else:
            parent.Total = parent.Total + difference

    def copy(self, parentid):
        """copy returns an exact duplicate of this object,
           but with the ParentID specified.
        """
        copied = BudgetGroup(Name=self.Name,
                             Description=self.Description,
                             ParentID=parentid,
                             _Total = self.Total,
                             OrderCost=self.OrderCost,
                             ClaimedCost=self.ClaimedCost,
                             RunningCost=self.RunningCost,
                             IncomeRecieved=self.IncomeRecieved,
                             ClientCost=self.ClientCost,
                             ProjectedProfit=self.ProjectedProfit,
                             ActualProfit=self.ActualProfit)

        return copied

    def paste(self, source, sourcechildren):
        """paste appends a source object to the children of this node,
        and then recursively does the same with each child of the source object.
        """
        self.Children.append(source)
        # if the child is of type component copy the component with the
        # resource category id for use by the component's resource
        for child in sourcechildren:
            source.paste(child.copy(source.ID), child.Children)

    def getComponents(self):
        """Returns a list of all the Resources that are used by the children of
           the budgetgroup. The resources are retrieved from its children and any
           children that are components return their resource
        """
        componentlist = []
        for child in self.Children:
            if child.type == 'Component':
                componentlist.append(child)
            else:
                componentlist += child.getComponents()
        return componentlist

    def toChildDict(self):
        """ Returns a dictionary of this node used in the childview
        """
        subitem = []
        if len(self.Children) > 0:
            subitem = [{'Name': '...', 'NodeType': 'Default'}]

        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'Subitem': subitem,
                'NodeType': self.type,
                'NodeTypeAbbr' : 'G'}

    def toDict(self):
        return {'Name': self.Name,
                'Description' : self.Description,
                'budg_cost': str(self.Total),
                'order_cost': str(self.OrderCost),
                'run_cost': str(self.RunningCost),
                'claim_cost': str(self.ClaimedCost),
                'income_rec': str(self.IncomeRecieved),
                'client_cost': str(self.ClientCost),
                'proj_profit': str(self.ProjectedProfit),
                'act_profit': str(self.ActualProfit)}

    def getGridData(self):
        return {'name': self.Name,
            'id': self.ID,
            'node_type': self.type,
            'budg_cost': str(self.Total),
            'order_cost': str(self.OrderCost.quantize(Decimal('.01'))),
            'run_cost': str(self.RunningCost.quantize(Decimal('.01'))),
            'claim_cost': str(self.ClaimedCost.quantize(Decimal('.01'))),
            'income_rec': str(self.IncomeRecieved.quantize(Decimal('.01'))),
            'client_cost': str(self.ClientCost.quantize(Decimal('.01'))),
            'proj_profit': str(self.ProjectedProfit.quantize(Decimal('.01'))),
            'act_profit': str(self.ActualProfit.quantize(Decimal('.01')))}

    def __repr__(self):
        """Return a representation of this budgetgroup
        """
        return '<BudgetGroup(Name="%s", ID="%s", ParentID="%s")>' % (
            self.Name, self.ID, self.ParentID)


class BudgetItem(Node):
    """ A table representing a BudgetItem in Optimate, it has an ID, Name,
        Description, Quantity, Rate and ParentID that is the ID of its parent.
    """
    __tablename__ = 'BudgetItem'
    ID = Column(Integer,
                ForeignKey('Node.ID', ondelete='CASCADE'),
                primary_key=True)
    Name = Column(Text(50))
    Description = Column(Text(100))
    _Quantity = Column('Quantity', Float, default=0.0)
    _Rate = Column('Rate', Numeric)
    _Total = Column('Total', Numeric)
    _ItemQuantity = Column('Item Quantity', Float, default=1.0)
    _ItemTotal = Column('Item Total', Numeric)

    __mapper_args__ = {
        'polymorphic_identity': 'BudgetItem',
        'inherit_condition': (ID == Node.ID),
    }

    def recalculateTotal(self):
        """recursively recalculate the total of all the nodes in the hierarchy
        """
        rate = Decimal(0.00)
        for child in self.Children:
            rate += child.recalculateTotal()
        self._Rate = rate
        # self._Total = Decimal((1.0+self.Markup) *
        #     self.Quantity * float(self._Rate)).quantize(Decimal('.01'))
        # return self._Total
        self._ItemTotal = Decimal(self.ItemQuantity *
                                    float(self._Rate)).quantize(Decimal('.01'))
        return self._ItemTotal

    def resetTotal(self):
        """the rate of a budgetitem is based on the totals of it's children
           and the total is equal to rate * quantity. The rate is reset, the
           total recalculated and returned
        """
        # rate = Decimal(0.00)
        # for child in self.Children:
        #     rate += child.Total
        # self._Rate = rate
        # self.Total = (1.0+self.Markup) * self.Quantity * float(self._Rate)
        rate = Decimal(0.00)
        for child in self.Children:
            rate += child.ItemTotal
        self._Rate = rate
        self.ItemTotal = self.ItemQuantity * float(self._Rate)

    @hybrid_property
    def Total(self):
        """ Get the Total, if the Total is none it is reset
        """
        # if self._Total == None:
        #     self.resetTotal()
        # return self._Total.quantize(Decimal('.01'))
        return self.ItemTotal

    @Total.setter
    def Total(self, total):
        """ Set the total, update the parent's Total with the difference
            between the old total and the new total
        """
        # if self._Total == None:
        #     self.recalculateTotal()
        # oldtotal = self.Total
        # self._Total = Decimal(total).quantize(Decimal('.01'))
        # difference = self._Total - oldtotal

        # # update the parent with the new total
        # # since the total has changed, change the rate of any parent
        # # budgetitems, and then others
        # parent = self.Parent
        # if parent.type == 'BudgetItem':
        #     parent.Rate = parent.Rate + difference
        # else:
        #     if parent._Total == None:
        #         parent.resetTotal()
        #     else:
        #         parent.Total = parent.Total + difference

        self.ItemTotal = total

    @hybrid_property
    def ItemTotal(self):
        """ Get the Total, if the Total is none it is reset
        """
        if self._ItemTotal == None:
            self.resetTotal()
        return self._ItemTotal.quantize(Decimal('.01'))

    @ItemTotal.setter
    def ItemTotal(self, total):
        """ Set the total, update the parent's Total with the difference
            between the old total and the new total
        """
        if self._ItemTotal == None:
            self.recalculateTotal()
        oldtotal = self.ItemTotal
        self._ItemTotal = Decimal(total).quantize(Decimal('.01'))
        difference = self._ItemTotal - oldtotal

        # update the parent with the new total
        # since the total has changed, change the rate of any parent
        # budgetitems, and then others
        parent = self.Parent
        if parent.type == 'BudgetItem':
            parent.Rate = parent.Rate + difference
        else:
            if parent._Total == None:
                parent.resetTotal()
            else:
                parent.Total = parent.Total + difference

    @hybrid_property
    def Markup(self):
        """ Get the markup of this budgetitem
        """
        # return self._Markup
        return 0.0

    @Markup.setter
    def Markup(self, markup):
        """ Set the markup value, and change the total accordingly
        """
        # self._Markup = markup
        self.Total = (1.0+self.Markup) * self.Quantity * float(self.Rate)

    @hybrid_property
    def Rate(self):
        """ Get the Rate
        """
        if self._Rate == None:
            self.resetTotal()
        return self._Rate.quantize(Decimal('.01'))

    @Rate.setter
    def Rate(self, rate):
        """ Set the Rate and recalculate the total
        """
        self._Rate = Decimal(rate).quantize(Decimal('.01'))
        # when the rate changes recalculate the total
        self.Total = (1.0+self.Markup) * self.Quantity * float(self._Rate)

    @hybrid_property
    def Quantity(self):
        """ Get the Quantity
        """
        # return self._Quantity
        return self.ItemQuantity

    @Quantity.setter
    def Quantity(self, quantity):
        """ Set the Quantity and recalculate the total
        """
        # self._Quantity = quantity
        # # when the quantity changes recalculate the total
        # self.Total = (1.0+self.Markup) * self.Quantity * float(self.Rate)
        self.ItemQuantity = quantity

    @hybrid_property
    def ItemQuantity(self):
        """ Get the Quantity
        """
        return self._ItemQuantity

    @ItemQuantity.setter
    def ItemQuantity(self, quantity):
        """ Set the Quantity and recalculate the total
        """
        self._ItemQuantity = quantity
        # when the quantity changes recalculate the total
        self.ItemTotal = self.Quantity * float(self.Rate)

    def Subtotal(self):
        """ Subtotal for a BudgetItem returns nothing
        """
        return ""

    def copy(self, parentid):
        """ Copy returns an exact duplicate of this object,
            but with the ParentID specified.
        """
        copied = BudgetItem(Name=self.Name,
                            Description=self.Description,
                            ParentID=parentid,
                            _Quantity=self._Quantity,
                            _Rate=self._Rate,
                            _Total=self._Total,
                            _ItemQuantity = self._ItemQuantity,
                            _ItemTotal = self._ItemTotal,
                            OrderCost=self.OrderCost,
                            ClaimedCost=self.ClaimedCost,
                            RunningCost=self.RunningCost,
                            IncomeRecieved=self.IncomeRecieved,
                            ClientCost=self.ClientCost,
                            ProjectedProfit=self.ProjectedProfit,
                            ActualProfit=self.ActualProfit)

        return copied

    def paste(self, source, sourcechildren):
        """ Paste appends a source object to the children of this node,
            and then recursively does the same
            with each child of the source object.
        """
        self.Children.append(source)
        # if the child is of type component copy the component with the
        # resource category id for use by the component's resource
        for child in sourcechildren:
            source.paste(child.copy(source.ID), child.Children)

    def getComponents(self):
        """ Returns a list of all the Resources that are used by the children of
            the budgetitem. The resources are retrieved from its children and any
            children that are components return their resource
        """
        componentlist = []
        for child in self.Children:
            if child.type == 'Component':
                componentlist.append(child)
            else:
                componentlist += child.getComponents()
        return componentlist

    def toChildDict(self):
        """ Returns a dictionary of this node used in the childview
        """
        subitem = []
        if len(self.Children) > 0:
            subitem = [{'Name': '...', 'NodeType': 'Default'}]

        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'Subitem': subitem,
                'NodeType': self.type,
                'NodeTypeAbbr' : 'I'}

    def toDict(self):
        """ Returns a dictionary of all the attributes of this object.
        """
        return {'Name': self.Name,
                'Description' : self.Description,
                'Quantity' : self._Quantity,
                'ItemQuantity': self.ItemQuantity,
                'budg_cost': str(self.Total),
                'order_cost': str(self.OrderCost),
                'run_cost': str(self.RunningCost),
                'claim_cost': str(self.ClaimedCost),
                'income_rec': str(self.IncomeRecieved),
                'client_cost': str(self.ClientCost),
                'proj_profit': str(self.ProjectedProfit),
                'act_profit': str(self.ActualProfit)}

    def getGridData(self):
        """ Return the data needed for the slick grid in the
            required format
        """
        return {'name': self.Name,
            'id': self.ID,
            'node_type': self.type,
            'markup':self.Markup*100.0,
            'rate': str(self.Rate),
            'quantity': self.Quantity,
            'budg_cost': str(self.Total),
            'order_cost': str(self.OrderCost.quantize(Decimal('.01'))),
            'run_cost': str(self.RunningCost.quantize(Decimal('.01'))),
            'claim_cost': str(self.ClaimedCost.quantize(Decimal('.01'))),
            'income_rec': str(self.IncomeRecieved.quantize(Decimal('.01'))),
            'client_cost': str(self.ClientCost.quantize(Decimal('.01'))),
            'proj_profit': str(self.ProjectedProfit.quantize(Decimal('.01'))),
            'act_profit': str(self.ActualProfit.quantize(Decimal('.01')))}

    def __repr__(self):
        """ Return a representation of this budgetitem
        """
        return '<BudgetItem(Name="%s", ID="%s", ParentID="%s")>' % (
            self.Name, self.ID, self.ParentID)


# Association table for the many-to-many relationship between Component
# and Overhead
association_table = Table('ComponentOverheadAssociation', Base.metadata,
    Column('ComponentID', Integer, ForeignKey('Component.ID')),
    Column('OverheadID', Integer, ForeignKey('Overhead.ID'))
)


class Component(Node):
    """ A component represents a unique component in the project.
        It can be the child of a budgetitem
        It has a many-to-one relationship with Resource, which
        defines its Name, Description, and Rate.
    """
    __tablename__ = 'Component'
    ID = Column(Integer,
                ForeignKey('Node.ID', ondelete='CASCADE'),
                primary_key=True)
    ResourceID = Column(Integer, ForeignKey('Resource.ID'))
    _Quantity = Column('Quantity', Float, default=0.0)
    _Total = Column('Total', Numeric)
    _ItemQuantity = Column('Item Quantity', Float, default=1.0)
    _ItemTotal = Column('Item Total', Numeric)

    Resource = relationship('Resource',
                            foreign_keys='Component.ResourceID',
                            backref='Components')

    Overheads = relationship('Overhead',
                    secondary=association_table,
                    backref='Components')

    __mapper_args__ = {
        'polymorphic_identity': 'Component',
        'inherit_condition': (ID == Node.ID),
    }

    def recalculateTotal(self):
        """ Recalculate the total of this Component
        """
        # self._Total = Decimal((1.0+self.Markup) *
        #     self.Quantity * float(self.Rate)).quantize(Decimal('.01'))
        # return self._Total
        self._ItemTotal = Decimal((1.0+self.Markup) *
            self.ItemQuantity * float(self.Rate)).quantize(Decimal('.01'))
        return self._ItemTotal

    def resetTotal(self):
        """ The total of a component is based on its rate and quantity
        """
        # After the total is set the total property is updated
        # self.Total = (1.0+self.Markup) * self.Quantity * float(self.Rate)
        self.ItemTotal = (1.0+self.Markup)*self.ItemQuantity*float(self.Rate)

    @hybrid_property
    def Total(self):
        """ Get the Total, if it is None reset it
        """
        # if self._Total == None:
        #     self.resetTotal()
        # return self._Total.quantize(Decimal('.01'))
        return self.ItemTotal

    @Total.setter
    def Total(self, total):
        """ Set the Total and update the parent with the new value
        """
        # if self._Total == None:
        #     self.recalculateTotal()
        # oldtotal = self.Total
        # self._Total = Decimal(total).quantize(Decimal('.01'))
        # difference = self._Total - oldtotal
        # # since the total has changed, change the rate or total of the parent
        # parent = self.Parent

        # if difference != 0:
        #     if parent.type == 'BudgetItem':
        #         parent.Rate = parent.Rate + difference
        #     else:
        #         if parent._Total == None:
        #             parent.resetTotal()
        #         else:
        #             parent.Total = parent.Total + difference

        self.ItemTotal = total

    @hybrid_property
    def ItemTotal(self):
        """ Get the Total, if the Total is none it is reset
        """
        if self._ItemTotal == None:
            self.resetTotal()
        return self._ItemTotal.quantize(Decimal('.01'))

    @ItemTotal.setter
    def ItemTotal(self, total):
        """ Set the total, update the parent's Total with the difference
            between the old total and the new total
        """
        if self._ItemTotal == None:
            self.recalculateTotal()
        oldtotal = self.ItemTotal
        self._ItemTotal = Decimal(total).quantize(Decimal('.01'))
        difference = self._ItemTotal - oldtotal
        # since the total has changed, change the rate or total of the parent
        parent = self.Parent

        if difference != 0:
            if parent.type == 'BudgetItem':
                parent.Rate = parent.Rate + difference
            else:
                if parent._Total == None:
                    parent.resetTotal()
                else:
                    parent.Total = parent.Total + difference

    def Subtotal(self):
        """ Subtotal returns the total of the Component with the Overhead
            costs removed
        """
        return (self.Total/Decimal(1+self.Markup)).quantize(Decimal('.01'))

    @hybrid_property
    def Name(self):
        """ Get this Components Name, which returns the Resource's Name
        """
        return self.Resource.Name

    @Name.setter
    def Name(self, name):
        """ Set this Components Name, which sets the Resource's Name
        """
        self.Resource.Name = name

    @hybrid_property
    def Description(self):
        """ Get the Description property
        """
        return self.Resource.Description

    @Description.setter
    def Description(self, description):
        """ Set the Description property
        """
        self.Resource.Description = description

    @hybrid_property
    def Markup(self):
        """ Get the markup of this component
            It is a composite of all the Overhead percentages
        """
        composite = 1.0
        for overhead in self.Overheads:
            composite = composite*(overhead.Percentage+1.0)
        return composite-1

    @Markup.setter
    def Markup(self, markup):
        """ Set the markup value, and change the total accordingly
        """
        # self._Markup = markup
        self.Total = (1.0+self.Markup) * self.Quantity * float(self.Rate)

    @hybrid_property
    def Rate(self):
        """ Get the component's Rate, the Rate of this resource is returned
        """
        return self.Resource.Rate

    @Rate.setter
    def Rate(self, rate):
        """ The rate of the component is set by its resource
            So it cant be set from the component
        """
        # change the total when the rate changes
        self.Total = (1.0+self.Markup) * self.Quantity * float(rate)

    @hybrid_property
    def Quantity(self):
        """ Get the Quantity
        """
        # return self._Quantity
        return self.ItemQuantity

    @Quantity.setter
    def Quantity(self, quantity):
        """ Set the Quantity and change the total
        """
        # self._Quantity = quantity
        # # change the total when the quantity changes
        # self.Total = (1.0+self.Markup) * self.Quantity * float(self.Rate)
        self.ItemQuantity = quantity

    @hybrid_property
    def ItemQuantity(self):
        """ Get the Quantity
        """
        return self._ItemQuantity

    @ItemQuantity.setter
    def ItemQuantity(self, quantity):
        """ Set the Quantity and recalculate the total
        """
        self._ItemQuantity = quantity
        # when the quantity changes recalculate the total
        self.ItemTotal = (1.0+self.Markup) * self.ItemQuantity*float(self.Rate)

    @hybrid_property
    def Unit(self):
        """ Get the component's Unit, the Unit of this resource is returned
        """
        if self.Resource:
            return self.Resource.unitName()

    @Unit.setter
    def Unit(self, unit):
        """ The Unit of the component is set by its resource
        """
        pass

    def overheadsList(self):
        """ Return a list of all the overheads used for this component
        """
        overheadlist = []
        for overhead in self.Overheads:
            overheadlist.append({'overhead_name': overhead.Name,
                                'percentage': str(overhead.Percentage*100)})

        return overheadlist

    def copy(self, parentid):
        """ copy returns an exact duplicate of this component,
            but with the ParentID specified and a copied resource
        """
        copied = Component(ParentID=parentid,
                            ResourceID = self.ResourceID,
                            _Quantity=self._Quantity,
                            _Total=self._Total,
                            _ItemQuantity = self._ItemQuantity,
                            _ItemTotal = self._ItemTotal,
                            OrderCost=self.OrderCost,
                            ClaimedCost=self.ClaimedCost,
                            RunningCost=self.RunningCost,
                            IncomeRecieved=self.IncomeRecieved,
                            ClientCost=self.ClientCost,
                            ProjectedProfit=self.ProjectedProfit,
                            ActualProfit=self.ActualProfit)
        return copied

    def paste(self, source, sourcechildren):
        """ Paste into this Component, make a copy of the resource the
            component uses and add it the new component
        """
        pass

    def getComponents(self):
        """ A component returns nothing
        """
        pass

    def toChildDict(self):
        """ Returns a dictionary of this node used in the childview
        """
        subitem = []
        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'Subitem': subitem,
                'NodeType': self.type,
                'NodeTypeAbbr' : 'C'}

    def toOrderDict(self):
        """ Returns a dictionary of this node used in the order tree view
        """
        total = self.Quantity*float(self.Rate)
        return {'Name': self.Name,
                'ID': self.ID,
                'id': self.ID,
                'Quantity': self.Quantity,
                'Rate': str(self.Rate),
                'Total': total,
                'NodeType': self.type,
                'node_type': self.type,
                'NodeTypeAbbr' : 'C'}

    def toDict(self):
        """ Return a dictionary of all the attributes of this Component
            Also returns a list of the Overhead ID's used by this component
        """
        overheadlist = []
        for overhead in self.Overheads:
            overheadlist.append(overhead.ID)
        resource = DBSession.query(Resource).filter_by(ID=self.ResourceID).first()

        return {'Name': self.Name,
                'Quantity': self.Quantity,
                'ItemQuantity': self.ItemQuantity,
                'ResourceID': self.ResourceID,
                'ResourceName': resource.Name,
                'OverheadList': overheadlist,
                'order_cost': str(self.OrderCost),
                'run_cost': str(self.RunningCost),
                'claim_cost': str(self.ClaimedCost),
                'income_rec': str(self.IncomeRecieved),
                'client_cost': str(self.ClientCost),
                'proj_profit': str(self.ProjectedProfit),
                'act_profit': str(self.ActualProfit)}

    def getGridData(self):
        """ Return a dictionary of all the data needed for the slick grid

        """
        return {'name': self.Name,
            'id': self.ID,
            'node_type': self.type,
            'overheads': self.overheadsList(),
            'quantity': self.Quantity,
            'rate': str(self.Rate),
            'budg_cost': str(self.Total),
            'sub_cost':str(self.Subtotal()),
            'unit': self.Unit,
            'order_cost': str(self.OrderCost.quantize(Decimal('.01'))),
            'run_cost': str(self.RunningCost.quantize(Decimal('.01'))),
            'claim_cost': str(self.ClaimedCost.quantize(Decimal('.01'))),
            'income_rec': str(self.IncomeRecieved.quantize(Decimal('.01'))),
            'client_cost': str(self.ClientCost.quantize(Decimal('.01'))),
            'proj_profit': str(self.ProjectedProfit.quantize(Decimal('.01'))),
            'act_profit': str(self.ActualProfit.quantize(Decimal('.01')))}

    def __repr__(self):
        """ return a representation of this component
        """
        return '<Co(Name="%s", Quantity="%d", ID="%s", ParentID="%s")>' % (
            self.Name, self.Quantity, self.ID, self.ParentID)


class Overhead(Base):
    """ A Table for the overheads a project incurs
    """
    __tablename__ = 'Overhead'
    ID = Column(Integer, primary_key=True)
    Name = Column(Text(50))
    Percentage = Column(Float, default=0.0)
    ProjectID = Column(Integer, ForeignKey('Project.ID'))

    def __repr__(self):
        """Return a representation of this overhead
        """
        return '<Overhead(Name="%s", Percentage="%f", ID="%s")>' % (
            self.Name, self.Percentage, self.ID)


class ResourceCategory(Node):
    """ ResourceCategory represents a unique set of resources used in a project
    """
    __tablename__ = 'ResourceCategory'
    ID = Column(Integer,
                ForeignKey('Node.ID', ondelete='CASCADE'),
                primary_key=True)
    Name = Column(Text(50))
    Description = Column(Text(100))
    # Total is just a dummy column for when a project is calculating its total
    _Total = Column('Total', Numeric(12, 2), default=Decimal(0.00))

    __mapper_args__ = {
        'polymorphic_identity': 'ResourceCategory',
        'inherit_condition': (ID == Node.ID),
    }

    def resetTotal(self):
        return Decimal(0.00)

    def recalculateTotal(self):
        return Decimal(0.00)

    @hybrid_property
    def Total(self):
        return Decimal(0.00)

    @Total.setter
    def Total(self, total):
        pass

    def getResources(self):
        """ Returns a list of all the resources in this category
            plus resources in its child categories
        """
        rlist = []
        for child in self.Children:
            if child.type == 'ResourceCategory':
                rlist += child.getResources()
            else:
                rlist.append(child)

        return rlist

    def getResourcesDetail(self):
        """ Returns a list of all the resources in this category
            plus resources in its child categories
        """
        rlist = []
        for child in self.Children:
            if child.type == 'ResourceCategory':
                rlist += child.getResourcesDetail()
            else:
                rlist.append({'title': str(child.Name),
                              'uid': str(child.ID),
                              'normalized_type': 'document' })

        return rlist

    def addResources(self, resourcelist):
        """ Add a list of resources to this ResourceCategory.
            The Resource is extracted from the component, tested if it is in
            the ResourceCategory, and appended
        """
        completeResourcesList = self.getResources()
        for resource in resourcelist:
            if resource not in completeResourcesList:
                # add the resource to the category
                self.Children.append(resource)

    def addResource(self, resource):
        """ check if the resource is already in this category and add it if not
        """
        if resource not in self.Children:
            self.Children.append(resource)
            return True
        else:
            return False

    def copy(self, parentid):
        """ copy returns an exact duplicate of this object,
            but with the ParentID specified.
        """
        copied = ResourceCategory(Name=self.Name,
                         Description=self.Description,
                         ParentID=parentid,
                         _Total = self.Total)
        return copied

    def paste(self, source, sourcechildren):
        """ Paste appends a source object to the children of this node,
            and then recursively does the same
            with each child of the source object.
        """
        self.Children.append(source)
        for child in sourcechildren:
            source.paste(child.copy(source.ID), child.Children)

    def toChildDict(self):
        """ Returns a dictionary of this node used in the childview
        """
        subitem = []
        if len(self.Children) > 0:
            subitem = [{'Name': '...', 'NodeType': 'Default'}]

        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'Subitem': subitem,
                'NodeType': self.type,
                'NodeTypeAbbr' : 'C'}

    def toDict(self):
        """ Returns a dictionary of this ResourceCategory
        """
        return {'Name': self.Name,
                'Description' : self.Description}

    def getGridData(self):
        """ Returns a dictionary with the data needed for the slick grid
        """
        return {'name': self.Name,
                'id': self.ID,
                'node_type': self.type}

    # functions to make the resource list iterable
    def __getitem__(self, index):
        return self.Children[index]

    def __setitem__(self, index, value):
        self.Children[index] = value

    def __delitem__(self, index):
        del self.Children[index]

    def __repr__(self):
        """Return a representation of this ResourceCategory
        """
        return '<ResourceCategory(Name="%s", ID="%s")>' % (
            self.Name, self.ID)


class ResourceType(Base):
    """ ResourceType defines the different type of resource
        It only has a unique name, it does not inherit from Node
        or form path of the project hierarchy
    """
    __tablename__ = 'ResourceType'
    Name = Column(Text(50), primary_key=True)

    Resources = relationship('Resource',
                              backref=backref('ResourceType'))

    def __repr__(self):
        return '<ResourceType(Name="%s")>' % (
            self.Name)


class Resource(Node):
    """ Resource represents a specific resource used in Optimate
        Each resource is unique and can be referenced by multiple Components
        Resource forms part of the Node hierarchy and has a ResourceCategory
        as it's parent.
        It has a _Rate attribute with a Rate property, when the Rate changes
        the component's Totals change as well
        It has a column name Type defined by the table ResourceType.
    """
    __tablename__ = 'Resource'
    ID = Column(Integer,
                ForeignKey('Node.ID', ondelete='CASCADE'),
                primary_key=True)
    Code = Column(Text(50))
    Name = Column(Text(50))
    Description = Column(Text(100))
    UnitID = Column(Integer, ForeignKey('Unit.ID'))
    Type = Column(Text(50), ForeignKey('ResourceType.Name'))
    _Rate = Column('Rate', Numeric, default=Decimal(0.00))

    __mapper_args__ = {
            'polymorphic_identity': 'Resource',
            'inherit_condition': (ID == Node.ID),
        }

    @hybrid_property
    def Rate(self):
        """ Get the Rate of the Resource
        """
        return self._Rate.quantize(Decimal('.01'))

    @Rate.setter
    def Rate(self, rate):
        """ Set the Resource's rate and reset the Rate of all the component's
            that reference it
        """
        self._Rate = Decimal(rate).quantize(Decimal('.01'))
        for comp in self.Components:
            comp.Rate = self._Rate

    def unitName(self):
        if self.Unit:
            return self.Unit.Name

    def copy(self, parentid):
        """copy returns an exact duplicate of this object,
        but with the ParentID specified.
        """
        copied = Resource(Name=self.Name,
                         Description=self.Description,
                         Type=self.Type,
                         Code = self.Code,
                         UnitID = self.UnitID,
                         ParentID=parentid,
                         _Rate = self.Rate)
        return copied

    def paste(self, source, sourcechildren):
        """ Do nothing. Cant paste into a resource
        """
        pass

    def toChildDict(self):
        """ Returns a dictionary of this node used in the childview
        """
        subitem = []
        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'Subitem': subitem,
                'NodeType': self.type,
                'NodeTypeAbbr' : 'R'}

    def toDict(self):
        return {'Name': self.Name,
                'Description': self.Description,
                'Rate': str(self._Rate),
                'ResourceType': self.Type,
                'Unit': self.UnitID}

    def getGridData(self):
        return {'name': self.Name,
                'id': self.ID,
                'unit': self.unitName(),
                'node_type': self.type,
                'rate': str(self.Rate),
                'type': self.Type}

    def __eq__(self, other):
        """Test for equality, for now testing based on the name
        """
        if other == None:
            return False
        else:
            return self.Name == other.Name

    def __getitem__(self, index):
        return self.Name[index].lower()

    def __repr__(self):
        """Return a representation of this resource
        """
        return '<Resource(Name="%s", Code="%s", Rate="%f", ID="%s")>' % (
            self.Name, self.Code, self.Rate, self.ID)


class Unit(Base):
    """ Unit defines a unit used by a Resource
    """
    __tablename__ = 'Unit'
    ID = Column(Integer, primary_key=True)
    Name = Column(Text(50))

    Resources = relationship('Resource',
                              backref=backref('Unit'))

    def __repr__(self):
        return '<Unit(Name="%s", ID="%d")>' % (
            self.Name, self.ID)


class Client(Base):
    """ A table containing the data relevant to a client of Optimate
    """
    __tablename__ = 'Client'
    ID = Column(Integer, primary_key=True, index=True)
    Name = Column(Text(50))
    Address = Column(Text(100))
    CityID = Column(Integer, ForeignKey('City.ID'))
    StateProvince = Column(Text(50))
    Country = Column(Text(50))
    Zipcode = Column(Text(50))
    Phone = Column(Text(50))
    Fax = Column(Text(50))
    Cellular = Column(Text(50))
    Contact = Column(Text(50))
    VAT = Column(Text(50))
    RegNo = Column(Text(50))

    def toDict(self):
        """ Return a dictionary of this Client
        """
        return {'Name': self.Name,
                'ID': self.ID,
                'Address': self.Address,
                'City': self.CityID,
                'StateProvince': self.StateProvince,
                'Country': self.Country,
                'Zipcode': self.Zipcode,
                'Phone': self.Phone,
                'Fax': self.Fax,
                'Cellular': self.Cellular,
                'Contact': self.Contact,
                'VAT': self.VAT,
                'RegNo': self.RegNo}

    def __repr__(self):
        """Return a representation of this client
        """
        return '<Client(Name="%s", ID="%s")>' % (
            self.Name, self.ID)


class Supplier(Base):
    """A table containing the data relavent to a supplier of Optimate
    """
    __tablename__ = 'Supplier'
    ID = Column(Integer, primary_key=True, index=True)
    Name = Column(Text(50))
    Address = Column(Text(100))
    CityID = Column(Integer, ForeignKey('City.ID'))
    StateProvince = Column(Text(50))
    Country = Column(Text(50))
    Zipcode = Column(Text(50))
    Phone = Column(Text(50))
    Fax = Column(Text(50))
    Cellular = Column(Text(50))
    Contact = Column(Text(50))

    def toDict(self):
        """ Return a dictionary of this Supplier
        """
        return {'Name': self.Name,
                'ID': self.ID,
                'Address': self.Address,
                'City': self.CityID,
                'StateProvince': self.StateProvince,
                'Country': self.Country,
                'Zipcode': self.Zipcode,
                'Phone': self.Phone,
                'Fax': self.Fax,
                'Cellular': self.Cellular,
                'Contact': self.Contact}

    def __repr__(self):
        """Return a representation of this supplier
        """
        return '<Supplier(Name="%s", ID="%s")>' % (
            self.Name, self.ID)


class CompanyInformation(Base):
    """A table containing the company information data of Optimate
    """
    __tablename__ = 'CompanyInformation'
    ID = Column(Integer, primary_key=True)
    Name = Column(Text(50))
    Address = Column(Text(100))
    Tel = Column(Text(50))
    Fax = Column(Text(50))
    Cell = Column(Text(50))
    BankName = Column(Text(50))
    BranchCode = Column(Text(50))
    AccountNo = Column(Text(50))
    AccountName = Column(Text(50))
    DefaultTaxrate = Column(Float)

    def __repr__(self):
        """Return a representation of this company information
        """
        return '<CompanyInformation(Name="%s", Address="%s")>' % (
            self.Name, self.Address)


class Order(Base):
    """ A table containing the data relavent to an order of Optimate
    """
    __tablename__ = 'Order'
    ID = Column(Integer, primary_key=True, index=True)
    UserCode = Column(Text(50))
    Authorisation = Column(Text(50))
    ProjectID = Column(Integer, ForeignKey('Project.ID'))
    SupplierID = Column(Integer, ForeignKey('Supplier.ID'))
    ClientID = Column(Integer, ForeignKey('Client.ID'))
    Total = Column(Numeric)
    TaxRate = Column(Float)
    DeliveryAddress = Column(Text(100))
    Date = Column(DateTime)
    Status = Column(Text(10))

    Project = relationship('Project',
                              backref=backref('Order'))
    Supplier = relationship('Supplier',
                              backref=backref('Order'))
    Client = relationship('Client',
                              backref=backref('Order'))

    def toDict(self):
        """ Returns a JSON dict of the order
        """
        if self.Project:
            projectname = self.Project.Name
        else:
            projectname = ""
        if self.Supplier:
            suppname = self.Supplier.Name
        else:
            suppname = ""
        if self.Client:
            clientname = self.Client.Name
        else:
            clientname = ""
        if self.Total:
            total = '{:20,.2f}'.format(self.Total).strip()
        else:
            total = '{:20,.2f}'.format(0).strip()

        return {'ID': self.ID,
                'Project': projectname,
                'Supplier': suppname,
                'Client': clientname,
                'Total': total,
                'Status': self.Status}

    def __repr__(self):
        """Return a representation of this order
        """
        return '<Order(ID="%s", ProjectID="%s", ClientID="%s")>' % (
            self.ID, self.ProjectID, self.ClientID)


class OrderItem(Base):
    """ A table containing the data relevant to an order item of Optimate
    """
    __tablename__ = 'OrderItem'
    ID = Column(Integer, primary_key=True, index=True)
    OrderID = Column(Integer, ForeignKey('Order.ID'))
    ComponentID = Column(Integer, ForeignKey('Component.ID'))
    Quantity = Column('Quantity', Float, default=0.0)
    Rate = Column('Rate', Numeric)

    Order = relationship('Order',
                              backref=backref('OrderItems'))
    Component = relationship('Component',
                              backref=backref('OrderItem'))

    @hybrid_property
    def Total(self):
        """ Return the total. Total is Quantity*Rate
        """
        return (Decimal(self.Quantity)*self.Rate).quantize(Decimal('.01'))

    @Total.setter
    def Total(self, total):
        """ Set total property.
        """
        pass

    def toDict(self):
        """ Returns a dictionary of this OrderItem
        """
        return {'Name': self.Component.Name,
                'ID': self.ComponentID,
                'id': self.ComponentID,
                'Quantity': self.Quantity,
                'Rate': str(self.Rate),
                'Total': str(self.Total),
                'NodeType': 'Component',
                'node_type': 'Component',
                'NodeTypeAbbr' : 'C',}

    def getGridData(self):
        """ Returns a dictionary of this OrderItem for the slickgrid
        """
        return {'id': self.Component.ID,
                'name': self.Component.Name,
                'quantity': self.Quantity,
                'rate': str(self.Rate),
                'total': str(self.Total)}

    def __repr__(self):
        """Return a representation of this order item
        """
        return '<OrderItem(ID="%s", OrderID="%s", ComponentID="%s")>' % (
            self.ID, self.OrderID, self.ComponentID)

class User(Base):
    """ A table to hold user and their roles. """
    __tablename__ = 'User'
    ID = Column(Integer, primary_key=True)
    username = Column(Unicode(length=20), nullable=False, index=True)
    salt = Column(Unicode(length=64), nullable=True)
    password = Column(Unicode(length=64), nullable=True) # For an sha256 hash
    roles = Column(Text(20))

    def validate_password(self, password):
        return hashlib.sha256((self.salt + password).encode('utf-8')).hexdigest() == self.password

    def set_password(self, password):
        salt = os.urandom(32).encode('hex')
        h = hashlib.sha256((salt + password).encode('utf-8')).hexdigest()
        self.salt = unicode(salt)
        self.password = unicode(h)

class Invoice(Base):
    """ Table for invoices
    """
    __tablename__ = 'Invoice'
    ID = Column(Integer, primary_key=True)
    OrderID = Column(Integer, ForeignKey('Order.ID'))
    InvoiceNumber = Column(Integer)
    Date = Column(DateTime)
    Amount = Column(Numeric)

    Order = relationship('Order',
                              backref=backref('Invoices'))

    def toDict(self):
        """ Returns a dictionary of this Invoice
        """
        # get the date in json format
        jsondate = self.Date.isoformat()
        return {'ID': self.ID,
                'OrderID': self.OrderID,
                'InvoiceNumber': self.InvoiceNumber,
                'Date': jsondate,
                'Amount' : str(self.Amount)}

    def __repr__(self):
        """Return a representation of this invoice
        """
        return '<Invoice(ID="%s", OrderID="%s", InvoiceNumber="%s")>' % (
            self.ID, self.OrderID, self.InvoiceNumber)
