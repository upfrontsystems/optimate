""" Models file defines and builds the models used in Optimate
"""

import os
import hashlib
from zope.sqlalchemy import ZopeTransactionExtension
from sqlalchemy.ext.hybrid import hybrid_property
from decimal import *
from datetime import datetime
import sqlalchemy.types as types

from sqlalchemy.ext.declarative import (
    declarative_base,
    declared_attr
)

from sqlalchemy import (
    Table,
    Column,
    Index,
    Integer,
    Float,
    Text,
    Boolean,
    Unicode,
    DateTime,
    ForeignKey,
    ForeignKeyConstraint,
    func,
    select,
    case
)

from sqlalchemy.orm import (
    scoped_session,
    sessionmaker,
    relationship,
    backref,
)

# Build the session and base used for the project
DBSession = scoped_session(
    sessionmaker(extension=ZopeTransactionExtension('changed')))
Base = declarative_base()
global DefaultTaxRate
DefaultTaxRate = None

class SqliteNumeric(types.TypeDecorator):
    impl = types.String
    def load_dialect_impl(self, dialect):
        return dialect.type_descriptor(types.VARCHAR(100))
    def process_bind_param(self, value, dialect):
        return str(value)
    def process_result_value(self, value, dialect):
        if value != "None":
            return Decimal(value)
        else:
            return None

Numeric = SqliteNumeric

class Node(Base):

    """ The Node class is an extrapolation of the objects used in the hierarchy
        It has ID and ParentID attributes, the ParentID refers back to the ID
        of it's parent node.
        The ID of the node is generated by default using UUID.
        It also has a Children-Parent relationship attribute.
    """

    __tablename__ = 'Node'
    ID = Column(Integer, primary_key=True)
    ParentID = Column(
                    Integer,
                    ForeignKey('Node.ID', ondelete='CASCADE'),
                    index=True)
    OrderCost = Column(Numeric(12, 2), default=Decimal(0.00))
    ClaimedCost = Column(Numeric(12, 2), default=Decimal(0.00))
    RunningCost=Column(Numeric(12, 2), default=Decimal(0.00))
    IncomeReceived=Column(Numeric(12, 2), default=Decimal(0.00))
    ClientCost=Column(Numeric(12, 2), default=Decimal(0.00))
    ProjectedProfit=Column(Numeric(12, 2), default=Decimal(0.00))
    ActualProfit=Column(Numeric(12, 2), default=Decimal(0.00))
    type = Column(Text(50))

    Children = relationship('Node',
                            cascade='all',
                            backref=backref('Parent', remote_side='Node.ID'),
                            )

    __mapper_args__ = {
        'polymorphic_identity': 'Node',
        'polymorphic_on': type
    }

    @property
    def Total(self):
        return Decimal(0.00)

    @Total.setter
    def Total(self, total):
        pass

    def getProjectID(self):
        """ Recursively calls the parent of this node until it finds the project
            whose parent is the root
        """
        ptr = self
        while ptr.Parent and ptr.Parent.ID != 0:
            ptr = ptr.Parent
        if not ptr.Parent:
            return 0
        return ptr.ID

    def copy(self, parentid):
        """ copy returns an exact duplicate of this object,
            but with the ParentID specified.
        """
        copied = Node(OrderCost=self.OrderCost,
                    ClaimedCost=self.ClaimedCost,
                    RunningCost=self.RunningCost,
                    IncomeReceived=self.IncomeReceived,
                    ClientCost=self.ClientCost,
                    ProjectedProfit=self.ProjectedProfit,
                    ActualProfit=self.ActualProfit)
        return copied

    def paste(self, source, sourcechildren):
        """paste appends a source object to the children of this node,
           and then recursively does the same
           with each child of the source object.
        """
        self.Children.append(source)
        for child in sourcechildren:
            # The resource category is not pasted
            if child.type != 'ResourceCategory':
                source.paste(child.copy(source.ID), child.Children)

    def __repr__(self):
        return '<Node(ID="%s", ParentID="%s")>' % (self.ID, self.ParentID)


class Project(Node):
    """ A table representing a Project in Optimate, it has an ID, Name,
        Description and ParentID that is the ID of its parent.
        It inherits from Node, and it's ID is linked to Node.ID
        It has copy and paste functions.
        It's total, ordered, and claimed attributes have properties that fire
        events
    """
    __tablename__ = 'Project'
    ID = Column(Integer,
                ForeignKey('Node.ID', ondelete='CASCADE'),
                primary_key=True)
    Name = Column(Text(50))
    Description = Column(Text(100))
    ClientID = Column(Integer, ForeignKey('Client.ID'))
    CityID = Column(Integer, ForeignKey('City.ID'))
    SiteAddress = Column(Text(50))
    FileNumber = Column(Text(50))
    Ordered = Column(Numeric(12, 2), default=Decimal(0.00))
    Invoiced = Column(Numeric(12, 2), default=Decimal(0.00))
    _Total = Column('Total', Numeric)

    Clients = relationship('Client',
                            foreign_keys='Project.ClientID',
                            backref='Project')

    OverheadList = relationship('Overhead',
                                backref='Project')

    __mapper_args__ = {
        'polymorphic_identity': 'Project',
        'inherit_condition': (ID == Node.ID),
    }

    def clearCosts(self):
        """ Set the Total to zero and do the same for all
            children
        """
        self._Total = Decimal(0)
        for child in self.Children:
            if child.type != 'ResourceCategory':
                child.clearCosts()

    @property
    def Total(self):
        """ Get the total. If the Total has not been set yet, it is set to
            zero and recalculated
        """
        if not self._Total:
            total = Decimal(0.00)
            for child in self.Children:
                total += child.Total
            self._Total = total
        return self._Total.quantize(Decimal('.01'))

    @Total.setter
    def Total(self, total):
        """ Set total property.
        """
        self._Total = Decimal(total).quantize(Decimal('.01'))

    def copy(self, parentid=0):
        """ copy returns an exact duplicate of the project,
            but with the ParentID specified.
        """
        copied = Project(Name=self.Name,
                        Description=self.Description,
                        ParentID=parentid,
                        ClientID=self.ClientID,
                        CityID=self.CityID,
                        SiteAddress=self.SiteAddress,
                        FileNumber=self.FileNumber,
                        _Total = self.Total,
                        OrderCost=self.OrderCost,
                        ClaimedCost=self.ClaimedCost,
                        RunningCost=self.RunningCost,
                        IncomeReceived=self.IncomeReceived,
                        ClientCost=self.ClientCost,
                        ProjectedProfit=self.ProjectedProfit,
                        ActualProfit=self.ActualProfit,
                        Ordered=self.Ordered,
                        Invoiced=self.Invoiced)
        return copied

    def paste(self, source, sourcechildren):
        """ paste appends a source object to the children of this node,
            and then recursively does the same
            with each child of the source object.
        """
        self.Children.append(source)
        for child in sourcechildren:
            # The resource category is not pasted
            if child.type != 'ResourceCategory':
                source.paste(child.copy(source.ID), child.Children)

    def getBudgetItems(self):
        """ Returns a list of all the BudgetItems that are used in this project.
        """
        budgetitemslist = []
        for child in self.Children:
            if child.type != 'ResourceCategory':
                budgetitemslist += child.getBudgetItems()
        return budgetitemslist

    def getBudgetGroups(self):
        """ Return a list of all the budgetgroups that are in this project.
        """
        budgetgrouplist = []
        if len(self.Children) == 0:
            return [self]
        for child in self.Children:
            if child.type == 'BudgetGroup':
                budgetgrouplist.append(child)
            elif child.type != 'BudgetItem':
                budgetgrouplist += child.getBudgetGroups()
        return budgetgrouplist

    def dict(self):
        """ Override the dict function
        """
        subitem = []
        if len(self.Children) > 0:
            subitem = [{'Name': '...', 'NodeType': 'Default'}]
        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'id': self.ID,
                'ParentID': self.ParentID,
                'Subitem': subitem,
                'Client' : self.ClientID,
                'City' : self.CityID,
                'SiteAddress' : self.SiteAddress,
                'FileNumber' : self.FileNumber,
                'Ordered': str(self.Ordered.quantize(Decimal('.01'))),
                'Invoiced': str(self.Invoiced.quantize(Decimal('.01'))),
                'NodeType': self.type,
                'NodeTypeAbbr' : 'P'}

    def __repr__(self):
        """ Return a representation of this project
        """
        return '<Project(Name="%s", ID="%s", ParentID="%s")>' % (
            self.Name, self.ID, self.ParentID)


class City(Base):
    """ City defines a city used by a Project
    """
    __tablename__ = 'City'
    ID = Column(Integer, primary_key=True)
    Name = Column(Text(50))

    Projects = relationship('Project',
                         backref=backref('City'))
    Clients = relationship('Client',
                         backref=backref('City'))
    Suppliers = relationship('Supplier',
                         backref=backref('City'))

    def __repr__(self):
        return '<City(Name="%s", ID="%d")>' % (
            self.Name, self.ID)


class BudgetGroup(Node):
    """ A table representing a BudgetGroup in Optimate, it has an ID, Name,
        Description and ParentID that is the ID of its parent.
        It inherits from Node, and it's ID is linked to Node.ID
        It has copy and paste functions.
    """
    __tablename__ = 'BudgetGroup'
    ID = Column(Integer,
                ForeignKey('Node.ID', ondelete='CASCADE'), primary_key=True)
    Name = Column(Text(50))
    Description = Column(Text(100))
    _Total = Column('Total', Numeric)
    _Ordered = Column('Ordered', Numeric(12, 2), default=Decimal(0.00))
    _Invoiced = Column('Invoiced', Numeric(12, 2), default=Decimal(0.00))

    __mapper_args__ = {
        'polymorphic_identity': 'BudgetGroup',
        'inherit_condition': (ID == Node.ID),
    }

    def clearCosts(self):
        """ Set the Total to zero and do the same for all
            children
        """
        self._Total = Decimal(0)
        for child in self.Children:
            child.clearCosts()

    @property
    def Total(self):
        """ Get the total property, recalculate the Total if it is None
        """
        if self._Total == None:
            total = Decimal(0.00)
            for child in self.Children:
                total += child.Total
            self._Total = total
        return self._Total.quantize(Decimal('.01'))

    @Total.setter
    def Total(self, total):
        """ When the total is changed the parent's total is updated.
        """
        difference = Decimal(total).quantize(Decimal('.01')) - self.Total
        # update the parent with the new total
        self.Parent.Total = self.Parent.Total + difference
        self._Total = Decimal(total).quantize(Decimal('.01'))


    @hybrid_property
    def Ordered(self):
        """ Get the Ordered property
        """
        return self._Ordered.quantize(Decimal('.01'))

    @Ordered.setter
    def Ordered(self, ordered):
        """ When the order is changed the parent's order is updated.
        """
        oldamount = self.Ordered
        self._Ordered = Decimal(ordered).quantize(Decimal('.01'))
        difference = self._Ordered - oldamount
        # update the parent with the new total
        self.Parent.Ordered = self.Parent.Ordered + difference

    @hybrid_property
    def Invoiced(self):
        """ Get the Invoiced property
        """
        return self._Invoiced.quantize(Decimal('.01'))

    @Invoiced.setter
    def Invoiced(self, invoiced):
        """ When the invoice is changed the parent's invoiced is updated.
        """
        oldamount = self.Invoiced
        self._Invoiced = Decimal(invoiced).quantize(Decimal('.01'))
        difference = self._Invoiced - oldamount
        # update the parent with the new total
        self.Parent.Invoiced = self.Parent.Invoiced + difference

    def copy(self, parentid):
        """ Copy returns an exact duplicate of this object,
            but with the ParentID specified.
        """
        copied = BudgetGroup(Name=self.Name,
                            Description=self.Description,
                            ParentID=parentid,
                            _Total = self.Total,
                            OrderCost=self.OrderCost,
                            ClaimedCost=self.ClaimedCost,
                            RunningCost=self.RunningCost,
                            IncomeReceived=self.IncomeReceived,
                            ClientCost=self.ClientCost,
                            ProjectedProfit=self.ProjectedProfit,
                            ActualProfit=self.ActualProfit,
                            _Ordered=self.Ordered,
                            _Invoiced=self.Invoiced)
        return copied

    def paste(self, source, sourcechildren):
        """ Paste appends a source object to the children of this budgetgroup,
            and then recursively does the same with each child
            of the source object.
        """
        self.Children.append(source)
        for child in sourcechildren:
            source.paste(child.copy(source.ID), child.Children)

    def getBudgetItems(self):
        """ Returns a list of all the BudgetItems in this BudgetGroup.
        """
        budgetitemslist = []
        for child in self.Children:
            budgetitemslist += child.getBudgetItems()
        return budgetitemslist

    def getBudgetGroups(self):
        """ Returns a list of all the budgetgroups that contained in this
            budgetgroup.
        """
        budgetgrouplist = []
        if len(self.Children) == 0:
            return [self]
        for child in self.Children:
            if child.type == 'BudgetGroup':
                budgetgrouplist.append(child)
            elif child.type != 'BudgetItem':
                budgetgrouplist += child.getBudgetGroups()
        return budgetgrouplist

    def dict(self):
        """ Override the dict function
        """
        subitem = []
        if len(self.Children) > 0:
            subitem = [{'Name': '...', 'NodeType': 'Default'}]
        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'id': self.ID,
                'ParentID': self.ParentID,
                'Subitem': subitem,
                'Ordered': str(self.Ordered),
                'Invoiced': str(self.Invoiced),
                'NodeType': self.type,
                'NodeTypeAbbr' : 'G'}

    def updateOrdered(self, ordered):
        """ Updates the Ordered amount for all the children of this node
        """
        self.Ordered = ordered
        for child in self.Children:
            child.updateOrdered(ordered)

    def __repr__(self):
        """Return a representation of this budgetgroup
        """
        return '<BudgetGroup(Name="%s", ID="%s", ParentID="%s")>' % (
            self.Name, self.ID, self.ParentID)

# Association table for the many-to-many relationship between BudgetItem
# and Overhead
association_table = Table('BudgetItemOverheadAssociation', Base.metadata,
    Column('BudgetItemID', Integer, ForeignKey('BudgetItem.ID')),
    Column('OverheadID', Integer, ForeignKey('Overhead.ID'))
)

class BudgetItem(Node):
    """ A BudgetItem represents a unique cost item in the project.
        It can be the child of another BudgetItem or a BudgetGroup
        It has a many-to-one relationship with Resource, which
        defines its Name, Description, and Rate.
    """
    __tablename__ = 'BudgetItem'
    ID = Column(Integer,
                ForeignKey('Node.ID', ondelete='CASCADE'),
                primary_key=True)
    ResourceID = Column(Integer, ForeignKey('Resource.ID'))
    _Quantity = Column('Quantity', Float, default=0.0)
    _Total = Column('Total', Numeric)
    _Ordered = Column('Ordered', Numeric(12, 2), default=Decimal(0.00))
    _Invoiced = Column('Invoiced', Numeric(12, 2), default=Decimal(0.00))

    Resource = relationship('Resource',
                            foreign_keys='BudgetItem.ResourceID',
                            backref='BudgetItems')

    Overheads = relationship('Overhead',
                    secondary=association_table,
                    backref='BudgetItems')

    __mapper_args__ = {
        'polymorphic_identity': 'BudgetItem',
        'inherit_condition': (ID == Node.ID),
    }

    def clearCosts(self):
        """ Set the Total and Quantity costs to zero
        """
        self._Total = Decimal(0)
        self._Quantity = 0.0

    @property
    def Name(self):
        """ Get this BudgetItem's Name, which returns the Resource's Name
        """
        if self.Resource:
            return self.Resource.Name
        else:
            return "no resource"

    @property
    def Description(self):
        """ Get the BudgetItem's Description, return Resource's Description
        """
        return self.Resource.Description

    @hybrid_property
    def Rate(self):
        """ Get the Rate, return the Resource Rate
        """
        return self.Resource.Rate

    @Rate.setter
    def Rate(self, rate):
        """ Update the Total from changes to the Resource Rate
        """
        self.Total = Decimal((1.0+self.Markup) * self.Quantity * float(rate)
                                ).quantize(Decimal('.01'))

    @property
    def Unit(self):
        """ Get the BudgetItem's Unit, the Unit of the Resource is returned
        """
        return self.Resource.unitName()

    @property
    def UnitID(self):
        """ Get the BudgetItem's Unit ID, the Unit of the Resource is returned
        """
        return self.Resource.UnitID

    @property
    def Type(self):
        """ Get the BudgetItem's Type, the Type of the Resource is returned
        """
        return self.Resource.Type

    @property
    def Markup(self):
        """ Get the markup of this BudgetItem.
            It is a composite of all the Overhead percentages
        """
        composite = 1.0
        for overhead in self.Overheads:
            composite = composite*(overhead.Percentage/100.0+1.0)
        return composite-1

    @property
    def Total(self):
        """ Get the Total, if it is None recalculate it
        """
        if self._Total == None:
            self._Total = Decimal((1.0+self.Markup) * self.Quantity * \
                                float(self.Rate)).quantize(Decimal('.01'))
        return self._Total.quantize(Decimal('.01'))

    @Total.setter
    def Total(self, total):
        """ Set the Total, update the parent's Total with the difference
            between the old total and the new total
        """
        difference = Decimal(total).quantize(Decimal('.01')) - self.Total
        # since the total has changed, change the total of the parent
        # if it is not a budgetitem
        if self.Parent.type != 'BudgetItem':
            self.Parent.Total = self.Parent.Total + difference
        self._Total = Decimal(total).quantize(Decimal('.01'))

    @property
    def Subtotal(self):
        """ Subtotal returns the total of the BudgetItem with the Overhead
            costs removed
        """
        return (self.Total/Decimal(1+self.Markup)).quantize(Decimal('.01'))

    @hybrid_property
    def Quantity(self):
        """ Get the Quantity.
        """
        return self._Quantity

    @Quantity.setter
    def Quantity(self, quantity):
        """ Set the Quantity and change the total
        """
        # change the total when the quantity changes
        self.Total = (1.0+self.Markup) * quantity * float(self.Rate)
        self._Quantity = quantity

    @hybrid_property
    def Ordered(self):
        """ Get the Ordered property
        """
        return self._Ordered.quantize(Decimal('.01'))

    @Ordered.setter
    def Ordered(self, ordered):
        """ When the order is changed the parent's order is updated.
        """
        oldamount = self.Ordered
        self._Ordered = Decimal(ordered).quantize(Decimal('.01'))
        difference = self._Ordered - oldamounts
        # update the parent with the new total
        self.Parent.Ordered = self.Parent.Ordered + difference

    @hybrid_property
    def Invoiced(self):
        """ Get the Invoiced property
        """
        return self._Invoiced.quantize(Decimal('.01'))

    @Invoiced.setter
    def Invoiced(self, invoiced):
        """ When the invoice is changed the parent's invoiced is updated.
        """
        oldamount = self.Invoiced
        self._Invoiced = Decimal(invoiced).quantize(Decimal('.01'))
        difference = self._Invoiced - oldamount
        # update the parent with the new total
        self.Parent.Invoiced = self.Parent.Invoiced + difference

    def paste(self, source, sourcechildren):
        """ Paste appends a source object to the children of this node,
            and then recursively does the same
            with each child of the source object.
        """
        self.Children.append(source)
        for child in sourcechildren:
            source.paste(child.copy(source.ID), child.Children)

    def getBudgetItems(self):
        """ Return a list of the leaf BudgetItems
        """
        budgetitemslist = []
        if len(self.Children) == 0:
            budgetitemslist = [self]
        else:
            for child in self.Children:
                budgetitemslist += child.getBudgetItems()
        return budgetitemslist

    def dict(self):
        """ Override the dict function
        """
        subitem = []
        if len(self.Children) > 0:
            subitem = [{'Name': '...', 'NodeType': 'Default'}]
        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'id': self.ID,
                'ParentID': self.ParentID,
                'ParentType': self.Parent.type,
                'Subitem': subitem,
                'Rate': str(self.Rate),
                'Quantity': self.Quantity,
                'Total': str(self.Total),
                'Ordered': str(self.Ordered),
                'Invoiced': str(self.Invoiced),
                'ResourceID': self.ResourceID,
                'ResourceName': self.Name,
                'OverheadList': self.overheadsList(),
                'Unit': self.Unit,
                'UnitID': self.UnitID,
                'ResourceTypeID': self.Type,
                'NodeType': self.type,
                'NodeTypeAbbr' : 'I'
        }

    def updateOrdered(self, ordered):
        """ Updates the Ordered amount for all the children of this node
        """
        self.Ordered = ordered
        for child in self.Children:
            child.updateOrdered(ordered)

    def overheadsList(self):
        """ Return a list of all the overheads used for this BudgetItem
        """
        overheadlist = []
        for overhead in self.Overheads:
            overheadlist.append(overhead.dict())

        return overheadlist

    def copy(self, parentid):
        """ copy returns an exact duplicate of this BudgetItem,
            but with the ParentID specified.
        """
        copied = BudgetItem(ParentID=parentid,
                            ResourceID = self.ResourceID,
                            _Quantity=self._Quantity,
                            _Total=self._Total,
                            OrderCost=self.OrderCost,
                            ClaimedCost=self.ClaimedCost,
                            RunningCost=self.RunningCost,
                            IncomeReceived=self.IncomeReceived,
                            ClientCost=self.ClientCost,
                            ProjectedProfit=self.ProjectedProfit,
                            ActualProfit=self.ActualProfit,
                            _Ordered=self.Ordered,
                            _Invoiced=self.Invoiced)
        return copied

    def order(self):
        """ The data returned when ordering a BudgetItem
        """
        orderitemsquantity = 0.0
        for orderitem in self.OrderItems:
            orderitemsquantity+=orderitem.Quantity
        quantity = self.Quantity - orderitemsquantity
        subtotal = Decimal(quantity*float(self.Rate)).quantize(Decimal('.01'))
        vat = 14
        companyinfo = DBSession.query(CompanyInformation
                                ).filter_by(ID=0).first()
        if companyinfo:
            vat = companyinfo.DefaultTaxrate
        total = Decimal(float(subtotal)*(1+vat/100.0)).quantize(Decimal('.01'))
        vatcost = Decimal(float(subtotal)*vat/100.0).quantize(Decimal('.01'))
        return {'Name': self.Name,
                'ID': self.ID,
                'ParentID': self.ParentID,
                'id': self.ID,
                'Quantity': quantity,
                'Rate': str(self.Rate),
                'Total': str(total),
                'VAT': vat,
                'VATCost': str(vatcost),
                'Subtotal': str(subtotal),
                'NodeType': 'OrderItem',
                'NodeTypeAbbr' : 'I'}

    def __repr__(self):
        """ return a representation of this BudgetItem
        """
        return '<BudgetItem(Name="%s", Quantity="%d", ID="%s", ParentID="%s")>' % (
            self.Name, self.Quantity, self.ID, self.ParentID)


class SimpleBudgetItem(BudgetItem):
    """ Similar to BudgetItem, but does not reference a resource. For adding
        simple cost items in ad hoc fashion.
    """
    __tablename__ = 'SimpleBudgetItem'
    ID = Column(Integer,
                ForeignKey('BudgetItem.ID', ondelete='CASCADE'),
                primary_key=True)
    Name = Column(Unicode(50))
    Description = Column(Text(100))
    Type = Column(Integer, ForeignKey('ResourceType.ID'))
    _Rate = Column('Rate', Numeric, default=Decimal(0.00))

    __mapper_args__ = {
        'polymorphic_identity': 'SimpleBudgetItem',
        'inherit_condition': (ID == BudgetItem.ID),
    }

    @property
    def Markup(self):
        """ Returns zero. No markup on simple BudgetItems.
        """
        return 0.0

    @property
    def Unit(self):
        """ Has no unit. """
        return None

    @property
    def UnitID(self):
        """ Has no unit
        """
        return None

    @hybrid_property
    def Rate(self):
        """ Get the Rate. If it is None return 0
        """
        if self._Rate == None:
            self._Rate = Decimal(0.00)
        return self._Rate.quantize(Decimal('.01'))

    @Rate.setter
    def Rate(self, rate):
        """ Set the Rate and update the Total
        """
        # change the total when the rate changes
        self.Total = (1.0+self.Markup) * self.Quantity * float(rate)
        self._Rate = Decimal(rate).quantize(Decimal('.01'))

    def copy(self, parentid):
        """ copy returns an exact duplicate of this SimpleBudgetItem,
            but with the ParentID specified.
        """
        return SimpleBudgetItem(ParentID=parentid,
                                Name=self.Name,
                                Description=self.Description,
                                _Quantity=self._Quantity,
                                _Total=self._Total,
                                Type=self.Type,
                                _Rate=self._Rate,
                                OrderCost=self.OrderCost,
                                ClaimedCost=self.ClaimedCost,
                                RunningCost=self.RunningCost,
                                IncomeReceived=self.IncomeReceived,
                                ClientCost=self.ClientCost,
                                ProjectedProfit=self.ProjectedProfit,
                                ActualProfit=self.ActualProfit,
                                _Ordered=self.Ordered,
                                _Invoiced=self.Invoiced)

    def __repr__(self):
        """ return a representation of this simplebudgetitem
        """
        return '<SimpleBudgetItem(Name="%s", Quantity="%d", ID="%s", ParentID="%s")>' % (
            self.Name, self.Quantity, self.ID, self.ParentID)


class Overhead(Base):
    """ A Table for the overheads a project incurs
    """
    __tablename__ = 'Overhead'
    ID = Column(Integer, primary_key=True)
    Name = Column(Text(50))
    Percentage = Column(Float, default=0.0)
    ProjectID = Column(Integer, ForeignKey('Project.ID'))

    def copy(self, projectid):
        """ Return a copy of this Overhead but with the ProjectID specified
        """
        return Overhead(Name=self.Name,
                        Percentage=self.Percentage,
                        ProjectID=projectid)

    def dict(self):
        """ Override the dict function
        """
        return {'ID': self.ID,
                'Name': self.Name,
                'Percentage': str(self.Percentage)}

    def __eq__(self, other):
        """ Test ifthis Overheadis equal to another Overhead by Name and
            Percentage
        """
        return ((self.Name == other.Name) and
            (self.Percentage == other.Percentage))

    def __repr__(self):
        """Return a representation of this overhead
        """
        return '<Overhead(Name="%s", Percentage="%f", ID="%s")>' % (
            self.Name, self.Percentage, self.ID)


class ResourceCategory(Node):
    """ ResourceCategory represents a unique set of resources used in a project
    """
    __tablename__ = 'ResourceCategory'
    ID = Column(Integer,
                ForeignKey('Node.ID', ondelete='CASCADE'),
                primary_key=True)
    Name = Column(Text(50))
    Description = Column(Text(100))
    # Total is just a dummy column for when a project is calculating its total
    _Total = Column('Total', Numeric(12, 2), default=Decimal(0.00))

    __mapper_args__ = {
        'polymorphic_identity': 'ResourceCategory',
        'inherit_condition': (ID == Node.ID),
    }

    def getResources(self):
        """ Returns a list of all the resources in this category
            plus resources in its child categories
        """
        rlist = []
        for child in self.Children:
            rlist += child.getResources()
        return rlist

    def getResourcesDetail(self):
        """ Returns a list of all the resources in this category
            plus resources in its child categories
        """
        rlist = []
        for child in self.Children:
            if child.type == 'ResourceCategory':
                rlist += child.getResourcesDetail()
            else:
                rlist.append({'title': str(child.Name),
                              'uid': str(child.ID),
                              'normalized_type': 'document' })

        return rlist

    def addResources(self, resourcelist):
        """ Add a list of resources to this ResourceCategory.
            The Resource is extracted from the BudgetItem, tested if it is in
            the ResourceCategory, and appended
        """
        completeResourcesList = self.getResources()
        for resource in resourcelist:
            if resource not in completeResourcesList:
                # add the resource to the category
                self.Children.append(resource)

    def addResource(self, resource):
        """ check if the resource is already in this category and add it if not
        """
        if resource not in self.Children:
            self.Children.append(resource)
            return True
        else:
            return False

    def copy(self, parentid):
        """ copy returns an exact duplicate of this object,
            but with the ParentID specified.
        """
        copied = ResourceCategory(Name=self.Name,
                         Description=self.Description,
                         ParentID=parentid,
                         _Total = self.Total)
        return copied

    def paste(self, source, sourcechildren):
        """ Paste appends a source object to the children of this node,
            and then recursively does the same
            with each child of the source object.
        """
        self.Children.append(source)
        for child in sourcechildren:
            source.paste(child.copy(source.ID), child.Children)

    def dict(self):
        """ Override the dict function
        """
        subitem = []
        if len(self.Children) > 0:
            subitem = [{'Name': '...', 'NodeType': 'Default'}]
        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'id': self.ID,
                'ParentID': self.ParentID,
                'Subitem': subitem,
                'NodeType': self.type,
                'NodeTypeAbbr' : 'C'}

    # functions to make the resource list iterable
    def __getitem__(self, index):
        return self.Children[index]

    def __setitem__(self, index, value):
        self.Children[index] = value

    def __delitem__(self, index):
        del self.Children[index]

    def __repr__(self):
        """Return a representation of this ResourceCategory
        """
        return '<ResourceCategory(Name="%s", ID="%s")>' % (
            self.Name, self.ID)


class ResourceType(Base):
    """ ResourceType defines the different type of resource
    """
    __tablename__ = 'ResourceType'
    ID = Column(Integer, primary_key=True)
    Name = Column(Text(50))
    DefaultMarkup = Column(Float, default=0.0)

    Resources = relationship('Resource',
                              backref=backref('ResourceType'))

    def __repr__(self):
        return '<ResourceType(Name="%s")>' % (
            self.Name)


class Resource(Node):
    """ Resource represents a specific resource used in Optimate
        Each resource is unique and can be referenced by multiple BudgetItems
        Resource forms part of the Node hierarchy and has a ResourceCategory
        as it's parent.
        It has a _Rate attribute with a Rate property, when the Rate changes
        the BudgetItem's Totals change as well
        It has a column name Type defined by the table ResourceType.
    """
    __tablename__ = 'Resource'
    ID = Column(Integer,
                ForeignKey('Node.ID', ondelete='CASCADE'),
                primary_key=True)
    Code = Column(Text(50))
    Name = Column(Text(50))
    Description = Column(Text(100))
    UnitID = Column(Integer, ForeignKey('Unit.ID'))
    Type = Column(Integer, ForeignKey('ResourceType.ID'))
    _Rate = Column('Rate', Numeric)
    SupplierID = Column(Integer, ForeignKey('Supplier.ID'))

    Suppliers = relationship('Supplier',
                              backref=backref('Resource'))

    __mapper_args__ = {
            'polymorphic_identity': 'Resource',
            'inherit_condition': (ID == Node.ID),
        }

    @property
    def Rate(self):
        """ Get the Rate, calculate it if it is None
        """
        if not self._Rate:
            rate = Decimal(0.00)
            for part in self.Children:
                rate+=part.Total
            self._Rate = rate.quantize(Decimal('.01'))
        return self._Rate.quantize(Decimal('.01'))

    @Rate.setter
    def Rate(self, rate):
        """ Set the Resource's rate and update the Total of all the
            BudgetItems and ResourceParts that reference it
        """
        for bi in self.BudgetItems:
            bi.Rate = rate
        for part in self.ResourceParts:
            part.Rate = rate
        self._Rate = Decimal(rate).quantize(Decimal('.01'))

    def unitName(self):
        if self.Unit:
            return self.Unit.Name

    def copy(self, parentid):
        """ Copy returns an exact duplicate of this object,
            but with the ParentID specified.
        """
        copied = Resource(Name=self.Name,
                         Description=self.Description,
                         Type=self.Type,
                         Code = self.Code,
                         UnitID = self.UnitID,
                         ParentID=parentid,
                         _Rate = self.Rate,
                         SupplierID = self.SupplierID)
        return copied

    def paste(self, source, sourcechildren):
        """ Do nothing. Cant paste into a resource
        """
        pass

    def overwrite(self, other):
        """ Overwrite this resource with the attributes of another resource
        """
        self.Name = other.Name
        self.Description= other.Description
        self.Type = other.Type
        self.Code = other.Code
        self.UnitID = other.UnitID
        self.Rate = other.Rate
        self.SupplierID = other.SupplierID

    def getResources(self):
        """ Return self as the only Resource
        """
        return [self]

    def dict(self):
        """ Override the dict function
        """
        typename = ""
        if self.ResourceType:
            typename = self.ResourceType.Name
        subitem = []
        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'id': self.ID,
                'ParentID': self.ParentID,
                'Subitem': subitem,
                'Code': self.Code,
                'Rate': str(self.Rate),
                'ResourceTypeID': self.Type,
                'ResourceType': typename,
                'UnitID': self.UnitID,
                'Unit': self.unitName(),
                'Supplier': self.SupplierID,
                'NodeType': self.type,
                'NodeTypeAbbr' : 'R'}

    def __eq__(self, other):
        """ Test for equality on the Resource product Code
        """
        if other == None:
            return False
        else:
            return self.Code == other.Code

    def __getitem__(self, index):
        return self.Name[index].lower()

    def __repr__(self):
        """ Return a representation of this resource
        """
        return '<Resource(Name="%s", Code="%s", Rate="%f", ID="%s")>' % (
            self.Name, self.Code, self.Rate, self.ID)


class ResourceUnit(Resource):
    """ A model that subclasses Resource and extends its functions
    """
    __tablename__ = "ResourceUnit"
    ID = Column(Integer,
                ForeignKey('Resource.ID', ondelete='CASCADE'),
                primary_key=True)

    __mapper_args__ = {
        'polymorphic_identity': 'ResourceUnit',
        'inherit_condition': (ID == Resource.ID),
    }

    def paste(self, source, sourcechildren):
        """ Paste a ResourcePart into this ResourceUnit
        """
        self.Children.append(source)

    def dict(self):
        """ Override the dict function
        """
        typename = ""
        if self.ResourceType:
            typename = self.ResourceType.Name
        subitem = []
        if len(self.Children) > 0:
            subitem = [{'Name': '...', 'NodeType': 'Default'}]
        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'id': self.ID,
                'ParentID': self.ParentID,
                'Subitem': subitem,
                'Code': self.Code,
                'Rate': str(self.Rate),
                'ResourceTypeID': self.Type,
                'ResourceType': typename,
                'UnitID': self.UnitID,
                'Unit': self.unitName(),
                'Supplier': self.SupplierID,
                'NodeType': self.type,
                'NodeTypeAbbr' : 'U'}

    def __repr__(self):
        """ Return a representation of this ResourceUnit
        """
        return '<ResourceUnit(Name="%s", Code="%s", Rate="%f", ID="%s")>' % (
            self.Name, self.Code, self.Rate, self.ID)


class ResourcePart(Node):
    """ Forms a part of a ResourceUnit
    """
    __tablename__ = "ResourcePart"
    ID = Column(Integer,
                ForeignKey('Node.ID', ondelete='CASCADE'),
                primary_key=True)
    ResourceID = Column(Integer, ForeignKey('Resource.ID'))
    _Quantity = Column('Quantity', Float)
    _Total = Column('Total', Numeric)

    Resource = relationship('Resource',
                            foreign_keys=[ResourceID],
                            backref=backref('ResourceParts'))

    __mapper_args__ = {
        'polymorphic_identity': 'ResourcePart',
        'inherit_condition': (ID == Node.ID),
    }

    @property
    def Total(self):
        """ Get the Total of the ResourcePart
        """
        if not self._Total:
            self._Total = Decimal(self.Quantity * float(self.Rate)
                            ).quantize(Decimal('.01'))
        return self._Total.quantize(Decimal('.01'))

    @Total.setter
    def Total(self, total):
        """ When the ResourcePart Total is set, update the
            parent ResourceUnit rate
        """
        difference = Decimal(total).quantize(Decimal('.01')) - self.Total
        self.Parent.Rate = self.Parent.Rate + difference
        self._Total = Decimal(total).quantize(Decimal('.01'))


    @property
    def Rate(self):
        """ Return the Rate of the Resource
        """
        return self.Resource.Rate

    @Rate.setter
    def Rate(self, rate):
        """ Update the Total from changes to the Resource Rate
        """
        self.Total = Decimal(self.Quantity * float(rate)).quantize(Decimal('.01'))

    @property
    def Name(self):
        """ Return the Name of the Resource
        """
        return self.Resource.Name

    @property
    def Description(self):
        """ Return the Description of the Resource
        """
        return self.Resource.Description

    @property
    def Quantity(self):
        """ Get the Quantity of the ResourcePart
        """
        return self._Quantity

    @Quantity.setter
    def Quantity(self, quantity):
        """ When the ResourcePart Quantity is set, update the Total
        """
        self.Total = Decimal(float(self.Rate) * float(quantity)
                                ).quantize(Decimal('.01'))
        self._Quantity = float(quantity)

    def copy(self, parentid):
        """ copy returns an exact duplicate of this ResourcePart,
            but with the ParentID specified.
        """
        copied = ResourcePart(ResourceID=self.ResourceID,
                        _Quantity=self.Quantity,
                        ParentID=parentid)
        return copied

    def paste(self, source, sourcechildren):
        """ Do nothing. Cant paste into a resource part
        """
        pass

    def dict(self):
        """ Override the dict function
        """
        subitem = []
        return {'Name': self.Name,
                'Description': self.Description,
                'ID': self.ID,
                'id': self.ID,
                'ParentID': self.ParentID,
                'Subitem': subitem,
                'Quantity': self.Quantity,
                'Rate': str(self.Rate),
                'Total': str(self.Total),
                'NodeType': self.type,
                'NodeTypeAbbr' : 'P'}

    def __repr__(self):
        """ Return a representation of this ResourcePart
        """
        return '<ResourcePart(Name="%s", Quantity"%f", Total="%f", ID="%s")>' % (
            self.Name, self.Quantity, self.Total, self.ID)


class Unit(Base):
    """ Unit defines a unit used by a Resource
    """
    __tablename__ = 'Unit'
    ID = Column(Integer, primary_key=True)
    Name = Column(Text(50))

    Resources = relationship('Resource',
                              backref=backref('Unit'))

    def __repr__(self):
        return '<Unit(Name="%s", ID="%d")>' % (
            self.Name, self.ID)


class Client(Base):
    """ A table containing the data relevant to a client of Optimate
    """
    __tablename__ = 'Client'
    ID = Column(Integer, primary_key=True, index=True)
    Name = Column(Text(50))
    Address = Column(Text(100))
    CityID = Column(Integer, ForeignKey('City.ID'))
    StateProvince = Column(Text(50))
    Country = Column(Text(50))
    Zipcode = Column(Text(50))
    Phone = Column(Text(50))
    Fax = Column(Text(50))
    Cellular = Column(Text(50))
    Contact = Column(Text(50))
    VAT = Column(Text(50))
    RegNo = Column(Text(50))

    def dict(self):
        """ Return a dictionary of this Client
        """
        return {'Name': self.Name,
                'ID': self.ID,
                'Address': self.Address,
                'City': self.CityID,
                'StateProvince': self.StateProvince,
                'Country': self.Country,
                'Zipcode': self.Zipcode,
                'Phone': self.Phone,
                'Fax': self.Fax,
                'Cellular': self.Cellular,
                'Contact': self.Contact,
                'VAT': self.VAT,
                'RegNo': self.RegNo}

    def __repr__(self):
        """Return a representation of this client
        """
        return '<Client(Name="%s", ID="%s")>' % (
            self.Name, self.ID)


class Supplier(Base):
    """A table containing the data relavent to a supplier of Optimate
    """
    __tablename__ = 'Supplier'
    ID = Column(Integer, primary_key=True, index=True)
    Name = Column(Text(50))
    Address = Column(Text(100))
    CityID = Column(Integer, ForeignKey('City.ID'))
    StateProvince = Column(Text(50))
    Country = Column(Text(50))
    Zipcode = Column(Text(50))
    Phone = Column(Text(50))
    Fax = Column(Text(50))
    Cellular = Column(Text(50))
    Contact = Column(Text(50))

    def dict(self):
        """ Return a dictionary of this Supplier
        """
        return {'Name': self.Name,
                'ID': self.ID,
                'Address': self.Address,
                'City': self.CityID,
                'StateProvince': self.StateProvince,
                'Country': self.Country,
                'Zipcode': self.Zipcode,
                'Phone': self.Phone,
                'Fax': self.Fax,
                'Cellular': self.Cellular,
                'Contact': self.Contact}

    def __repr__(self):
        """Return a representation of this supplier
        """
        return '<Supplier(Name="%s", ID="%s")>' % (
            self.Name, self.ID)


class CompanyInformation(Base):
    """A table containing the company information data of Optimate
    """
    __tablename__ = 'CompanyInformation'
    ID = Column(Integer, primary_key=True)
    Name = Column(Text(50))
    Address = Column(Text(100))
    Tel = Column(Text(50))
    Fax = Column(Text(50))
    Cell = Column(Text(50))
    BankName = Column(Text(50))
    BranchCode = Column(Text(50))
    AccountNo = Column(Text(50))
    AccountName = Column(Text(50))
    DefaultTaxrate = Column(Float)

    def __repr__(self):
        """Return a representation of this company information
        """
        return '<CompanyInformation(Name="%s", Address="%s")>' % (
            self.Name, self.Address)


class Order(Base):
    """ A table containing the data relavent to an order of Optimate
    """
    __tablename__ = 'Order'
    ID = Column(Integer, primary_key=True, index=True)
    UserCode = Column(Text(50))
    Authorisation = Column(Text(50))
    ProjectID = Column(Integer, ForeignKey('Project.ID'))
    SupplierID = Column(Integer, ForeignKey('Supplier.ID'))
    ClientID = Column(Integer, ForeignKey('Client.ID'))
    Total = Column(Numeric)
    DeliveryAddress = Column(Text(100))
    Date = Column(DateTime)
    Status = Column(Text(10))

    Project = relationship('Project',
                              backref=backref('Orders'))
    Supplier = relationship('Supplier',
                              backref=backref('Orders'))
    Client = relationship('Client',
                              backref=backref('Orders'))

    def resetTotal(self):
        """ Recalculate the Order Total from it's OrderItems
        """
        total = Decimal(0.00)
        for orderitem in self.OrderItems:
            total += orderitem.Total

        self.Total = Decimal(total).quantize(Decimal('.01'))

    def dict(self):
        """ Override the dict function
        """
        suppname = ""
        if self.Supplier:
            suppname = self.Supplier.Name
        clientname = ""
        if self.Client:
            clientname = self.Client.Name
        total = '{:20,.2f}'.format(0).strip()
        if self.Total:
            total = '{:20,.2f}'.format(self.Total).strip()
        date = ''
        if self.Date:
            date = self.Date.strftime("%d %B %Y")

        return {'ID': self.ID,
                'Date': date,
                'Project': self.Project.Name,
                'ProjectID': self.ProjectID,
                'Supplier': suppname,
                'SupplierID': self.SupplierID,
                'Client': clientname,
                'ClientID': self.ClientID,
                'Total': total,
                'Status': self.Status}

    def __repr__(self):
        """Return a representation of this order
        """
        return '<Order(ID="%s", ProjectID="%s", ClientID="%s")>' % (
            self.ID, self.ProjectID, self.ClientID)


class OrderItem(Base):
    """ A table containing the data relevant to an order item of Optimate
    """
    __tablename__ = 'OrderItem'
    ID = Column(Integer, primary_key=True, index=True)
    OrderID = Column(Integer, ForeignKey('Order.ID'))
    BudgetItemID = Column(Integer, ForeignKey('BudgetItem.ID'))
    VAT = Column(Float)
    _Quantity = Column(Float, default=0.0)
    _Rate = Column(Numeric(12, 2), default=Decimal(0.00))
    _Total = Column('Total', Numeric(12, 2))

    Order = relationship('Order',
                            backref=backref('OrderItems'))

    BudgetItem = relationship('BudgetItem',
                                backref=backref('OrderItems'))

    @hybrid_property
    def Total(self):
        """ Return the total. Total is Quantity*Rate*VAT
        """
        if not self._Total:
            self._Total = Decimal(
                self.Quantity*float(self.Rate)*(1 + (self.VAT/100.0))
                ).quantize(Decimal('.01'))
        return self._Total

    @Total.setter
    def Total(self, total):
        """ Set the total
        """
        self._Total = Decimal(total).quantize(Decimal('.01'))

    @property
    def Subtotal(self):
        """ Return the subtotal, which is VAT deducted from the Total
            deducted from it's total
        """
        return Decimal(float(self.Total)/(1.0+(self.VAT/100.0))).quantize(
                        Decimal('.01'))

    @hybrid_property
    def Rate(self):
        """ Get the Rate
        """
        if not self._Rate:
            self._Rate = Decimal(0.00)
        return self._Rate.quantize(Decimal('.01'))

    @Rate.setter
    def Rate(self, rate):
        """ Set the Rate and recalculate the total
        """
        self._Rate = Decimal(rate).quantize(Decimal('.01'))
        # when the rate changes recalculate the total
        self.Total = self.Quantity * float(self._Rate)

    @hybrid_property
    def Quantity(self):
        """ Get the Quantity
        """
        if not self._Quantity:
            self._Quantity = 0.00
        return self._Quantity

    @Quantity.setter
    def Quantity(self, quantity):
        """ Set the Quantity and recalculate the Total
        """
        self._Quantity = quantity
        self.Total = quantity * float(self._Rate)

    def dict(self):
        """ Override the dict function
        """
        vatcost = Decimal(float(self.Subtotal)*(self.VAT/100.0)
                            ).quantize(Decimal('.01'))
        return {'Name': self.BudgetItem.Name,
                'ID': self.BudgetItemID,
                'id': self.BudgetItemID,
                'Quantity': self.Quantity,
                'Unit': self.BudgetItem.Unit,
                'Rate': str(self.Rate),
                'VAT': self.VAT,
                'Subtotal': str(self.Subtotal),
                'Total': str(self.Total),
                'VATCost': str(vatcost),
                'NodeTypeAbbr' : 'I',
                'NodeType': 'OrderItem'}

    def __repr__(self):
        """Return a representation of this order item
        """
        return '<OrderItem(ID="%s", OrderID="%s", BudgetItemID="%s")>' % (
            self.ID, self.OrderID, self.BudgetItemID)


class User(Base):
    """ A table to hold user and their roles. """
    __tablename__ = 'User'
    ID = Column(Integer, primary_key=True)
    username = Column(Unicode(length=20), nullable=False, index=True)
    salt = Column(Unicode(length=64), nullable=True)
    password = Column(Unicode(length=64), nullable=True) # For an sha256 hash
    roles = Column(Text(20))

    def validate_password(self, password):
        return hashlib.sha256((self.salt + password).encode('utf-8')).hexdigest() == self.password

    def set_password(self, password):
        salt = os.urandom(32).encode('hex')
        h = hashlib.sha256((salt + password).encode('utf-8')).hexdigest()
        self.salt = unicode(salt)
        self.password = unicode(h)


class Invoice(Base):
    """ Table for invoices
    """
    __tablename__ = 'Invoice'
    ID = Column(Integer, primary_key=True)
    OrderID = Column(Integer, ForeignKey('Order.ID'))
    InvoiceDate = Column(DateTime)
    PaymentDate = Column(DateTime)
    VAT = Column(Numeric)
    Amount = Column(Numeric)

    Order = relationship('Order',
                              backref=backref('Invoices'))

    @hybrid_property
    def ProjectID(self):
        """ Return the id of the Project this Invoice's Order uses
        """
        return self.Order.ProjectID

    @ProjectID.expression
    def ProjectID(cls):
        """ Expression to filter Invoice by ProjectID
        """
        return select([Order.ProjectID]).where(cls.OrderID == Order.ID).as_scalar()

    @hybrid_property
    def ClientID(self):
        """ Return the id of the Client this Invoice's Order uses
        """
        return self.Order.ClientID

    @ClientID.expression
    def ClientID(cls):
        """ Expression to filter Invoice by ClientID
        """
        return select([Order.ClientID]).where(cls.OrderID == Order.ID).as_scalar()

    @hybrid_property
    def SupplierID(self):
        """ Return the id   of the Supplier this Invoice's Order uses
        """
        return self.Order.SupplierID

    @SupplierID.expression
    def SupplierID(cls):
        """ Expression to filter Invoice by SupplierID
        """
        return select([Order.SupplierID]).where(cls.OrderID == Order.ID).as_scalar()

    @hybrid_property
    def Status(self):
        """ Return paid if the payment date is in the past, otherwise unpaid
        """
        if self.PaymentDate:
            if self.PaymentDate < datetime.now():
                return 'Paid'
            else:
                return 'Unpaid'
        else:
            return 'Unpaid'

    @Status.expression
    def Status(cls):
        """ Expression to filter Invoice by Status
        """
        return case([(cls.PaymentDate == None, "Unpaid"),
                    (cls.PaymentDate > func.now(), "Unpaid")],
                    else_="Paid")

    @property
    def Subtotal(self):
        return self.Amount

    @property
    def Total(self):
        return Decimal(self.Amount + self.VAT).quantize(Decimal('.01'))

    def dict(self):
        """ Override the dict function
        """
        # get the date in json format
        jsonindate = None
        if self.InvoiceDate:
            jsonindate = self.InvoiceDate.strftime("%d %B %Y")
        jsonpaydate = None
        if self.PaymentDate:
            jsonpaydate = self.PaymentDate.strftime("%d %B %Y")
        return {'ID':self.ID,
                'id':self.ID,
                'OrderID': self.OrderID,
                'Project': self.Order.Project.Name,
                'Supplier': self.Order.Supplier.Name,
                'Amount': str(self.Amount),
                'VAT': str(self.VAT),
                'Paymentdate': jsonpaydate,
                'Invoicedate': jsonindate,
                'Ordertotal': str(self.Order.Total),
                'Status': self.Status}

    def toReportDict(self):
        """ Returns a dictionary of this Invoice for the invoice report
        """
        paydate = None
        if self.PaymentDate:
            paydate = self.PaymentDate.strftime("%d %B %Y")
        invoicedate = None
        if self.InvoiceDate:
            invoicedate = self.InvoiceDate.strftime("%d %B %Y")
        return {'id': self.ID,
                'orderid': self.OrderID,
                'project': self.Order.Project.Name,
                'supplier': self.Order.Supplier.Name,
                'invoicedate': invoicedate,
                'paymentdate': paydate,
                'total': str(self.Total),
                'status': self.Status}

    def __repr__(self):
        """ Return a representation of this invoice
        """
        return '<Invoice(ID="%s", OrderID="%s", InvoiceID="%s")>' % (
            self.ID, self.OrderID, self.ID)


class Valuation(Base):
    """ A table to hold valuations. """
    __tablename__ = 'Valuation'
    ID = Column(Integer, primary_key=True)
    ProjectID = Column(Integer, ForeignKey('Project.ID'))
    Date = Column(DateTime)

    Project = relationship('Project',
                              backref=backref('Valuations'))

    def dict(self):
        """ Override the dict function
        """
        if self.Date:
            date = self.Date.strftime("%d %B %Y")
        else:
            date = ''
        return {'ID': self.ID,
                'id': self.ID,
                'Project': self.Project.Name,
                'Date': date,
                'PercentageClaimed': str(self.TotalPercentage),
                'AmountClaimed': str(self.Total)}

    @property
    def TotalPercentage(self):
        if self.Project.Total == 0:
            return Decimal(0.00)
        totalp = (self.Total/self.Project.Total)*100
        return Decimal(totalp).quantize(Decimal('.01'))

    @property
    def Total(self):
        total = 0
        for valuationitem in self.ValuationItems:
            total += valuationitem.Total
        return Decimal(total).quantize(Decimal('.01'))

    def __repr__(self):
        """Return a representation of this valuation
        """
        return '<Valuation(ID="%s", ProjectID="%s", Date="%s")>' % (
            self.ID, self.ProjectID, self.Date)


class ValuationItem(Base):
    """ A table to hold valuation items. """
    __tablename__ = 'ValuationItem'
    ID = Column(Integer, primary_key=True)
    ValuationID = Column(Integer, ForeignKey('Valuation.ID'))
    BudgetGroupID = Column(Integer, ForeignKey('BudgetGroup.ID'))
    PercentageComplete = Column(Numeric)
    BudgetGroupTotal = Column('BudgetGroupTotal', Numeric) # stores snapshot of
                                                           #a budgetgroups total

    BudgetGroup = relationship('BudgetGroup',
                              backref=backref('BudgetGroups'))
    Valuation = relationship('Valuation',
                              backref=backref('ValuationItems'))

    def dict(self):
        """ Returns a dictionary of this ValuationItem
        """
        return {'ID': self.ID,
                'id': self.ID,
                'BudgetGroup': self.BudgetGroupID,
                'Name': self.BudgetGroup.Name,
                'PercentageComplete': str(self.PercentageComplete),
                'AmountComplete': str(self.Total),
                'TotalBudget': str(self.BudgetGroup.Total)}

    @property
    def Total(self):
        total = (self.BudgetGroup.Total / 100) * self.PercentageComplete
        return Decimal(total).quantize(Decimal('.01'))

    def __repr__(self):
        """Return a representation of this valuation item
        """
        return '<ValuationItem(ID="%s", BudgetGroupID="%s")>' % (
            self.ID, self.BudgetGroupID)
